\documentclass[a4paper,12pt]{report}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{mathrsfs}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
\usepackage{color}
\usepackage[cm-default]{fontspec}
\usepackage{xunicode}
\usepackage{xltxtra}
\usepackage[all,cmtip]{xy}
\usepackage{xgreek}

\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{minted}


\setmainfont[Mapping=tex-text]{GFS Neohellenic}

\title{ Αλγόριθμοι και Πολυπλοκότητα \\ 1η Σειρά Γραπτών Ασκήσεων}
\author{Γιαννέλος Γιάννης\\ΑΜ:03108088}

\begin{document}
\maketitle

\section*{Άσκηση 1: Ασυμπτωτικός Συμβολισμός, Αναδρομικές Σχέσεις}
\subsection*{(α)}
Ταξινομώντας τις συναρτήσεις της άσκησης σε αύξουσα σειρά τάξης μεγέθους προκύπτει η εξής διάταξη :
% \begin{center}
% \renewcommand{\arraystretch}{1.5}
% \begin{tabular}{ |l|l|l| } 
%   \hline
%   $g_1=e^{\frac{n}{\ln n}}$ & $g_2=\log{(n^3)}$ & $g_3=\log (n!)$ \\ \hline
%   $g_4=n^{1.01}$ & $g_5=\frac{n}{\log \log n}$ & $g_6=5^{\log{n}}$ \\ \hline
%   $g_7=(\log n)^{\log{n}}$ & $g_8=2^{({\log{n}})^4}$ & $g_9=\sqrt{n!}$ \\ \hline
%   $g_{10}=2^{2^n}$ & $g_{11}=n^{\log{\log{n}}}$ & $g_{12}=\sqrt{n} \cdot ({\log{n}}^{50})$ \\ \hline 
%   $g_{13}=n \cdot ({\log n})^{10}$ & $g_{14}=({\log n})^{\sqrt{n}}$ & $g_{15}=\sum\limits_{k=1}^{n} {k^5}$ \\ \hline 
%   $g_{16}=n\cdot 3^n$ & & \\ 
%   \hline
% \end{tabular}
% \end{center}

\begin{center}
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{ |l|l|l| } 
  \hline
  $g_1=\log n^3$ & $g_2=\sqrt{n} (\log n)^{50}$ & $g_3=\frac{n}{\log \log n}$ \\ \hline
  $g_4=\log n!$ & $g_5=n(\log n)^{10}$ & $g_6=n^{1.01}$ \\ \hline
  $g_7=5^{\log n}$ & $g_8=\sum\limits_{k=1}^{n}{k^5}$ & $g_9=(\log n)^{\log n}=n^{\log \log n}$ \\ \hline
  $g_{10}=2^{(\log n)^4}$ & $g_{11}=(\log n)^{\sqrt n}$ & $g_{12}=e^{\frac{n}{\ln n}}$ \\ \hline 
  $g_{13}=n \cdot 3^n$ & $g_{14}=2^{2n}$ & $g_{15}=\sqrt{n!}$ \\ \hline 
\end{tabular}
\end{center}


\subsection*{(β)}
\begin{enumerate}
 \item \textsc{Χρήση του Master Theorem}:
\begin{itemize}
 \item $\alpha=5$, $\beta=7$ άρα $n^{\log_{\beta}{\alpha}}=n^{\log_{7}{5}} \simeq n^{0.827}$
 \item $f(n)=n \log n=\Omega (n^{\log_{7}{5}+\epsilon})$ 
 \item $5f(\frac{n}{7})=5\frac{n}{7}log(\frac{n}{7}) \leq \frac{5}{7}n\log(n)$
\end{itemize}
Άρα σύμφωνα με την 3η περίπτωση του \textsc{Master Theorem} προκύπτει ότι: $T(n)=\Theta (n \log n)$ 
 \item \textsc{Χρήση του Master Theorem}:
\begin{itemize}
 \item $T(n)=4T(\frac{n}{5})+\frac{n}{(\log n)^2}$
 \item $n^{\log_{\beta}{\alpha}}=n^{\log_{5}{4}} \simeq n^{0.861}$
\end{itemize}
Άρα $T(n)=\Theta(\frac{n}{(\log n)^2})$
%   \item \textsc{Χρήση του Master Theorem}:
% \begin{itemize}
%  \item $\alpha = 4$, $\beta=5$ άρα $n^{\log_{\beta}{\alpha}}=n^{\log_{5}{4}} \simeq n^{0.861}$
%  \item $f(n)=\frac{n}{{\log n}^2}=O(n^{\log_{5}{5} -\epsilon})$
% \end{itemize}
% Άρα σύμφωνα με την πρώτη περίπτωση του \textsc{Master Theorem}  προκύπτει ότι $T(n)=\Theta (n^{\log_{\beta}{\alpha}})=\Theta (n^{\log_{5}{4}})$
 \item $T(n)=T(\frac{n}{3})+3T(\frac{n}{7})+n \Longrightarrow T(n) = \Theta (n \log n)$
 \item \textsc{Χρήση του Master Theorem}:
\begin{itemize}
 \item $\alpha=6$, $\beta=6$ άρα $n^{\log_{\beta}{\alpha}}=n^{\log_{6}{6}}=n$
 \item $f(n)=\Theta (n^{\log_{6}{6}})$
\end{itemize}
Άρα σύμφωνα με την 2η περίπτωση του \textsc{Master Theorem} προκύπτει ότι: $T(n)=\Theta (n \log n)$
 \item \textsc{Χρήση του Master Theorem}:
\begin{itemize}
 \item $T(n)$ της μορφής $T(n)=T(\gamma_1 n)+T(\gamma_2 n)+\Theta(n)$
 \item $\gamma_1 + \gamma_2 = \frac{1}{3} + \frac{2}{3} =1$
\end{itemize}
Άρα ισχύει $T(n)=\Theta (n\log n)$

 \item \textsc{Χρήση του Master Theorem}:
\begin{itemize}
 \item $\alpha=16$, $\beta=4$ άρα $n^{\log_{\beta}{\alpha}}=n^{\log_{4}{16}}=n^2$
 \item $f(n)=n^3 {log(n)}^2=\Omega (n^{\log_{16}{4}+\epsilon})$
 \item $\alpha f(\frac{n}{\beta})=16f(\frac{n}{4})=16\frac{n^3}{4^3}{log(\frac{n}{4})}^2=\frac{16}{4^3}n^3{\log({\frac{n}{4}})}^2 \leq cf(n)$ με $c<1$
\end{itemize}
Άρα σύμφωνα με την 3η περίπτωση του \textsc{Master Theorem} προκύπτει ότι: $T(n)=\Theta(n^3(\log n)^2)$
 \item $T(n)=T(\sqrt{n})+\Theta (\log \log n)$. Έστω $k=\log n$, $f(k)=T(n)$. Άρα $T(\sqrt{n})=f(\log \sqrt{n})=f(\frac{\log n}{2})=f(\frac{k}{2}) \Longrightarrow f(k)=f(k/2)+\Theta(\log k)$. Επομένως: $T(n)=\Theta (\frac{(\log k)^2(\log k +1)}{2})$
 \item $T(n) = T(n-3)+\log n \Longrightarrow T(n)=\Theta (n \log n)$
\end{enumerate}


\section*{Άσκηση 2: Ταξινόμηση σε πίνακα με πολλά ίδια στοιχεία}
\subsection*{(α)}
Ο πίνακας $A[1...n]$ χαρακτήριζεται απο πολλές εμφανίσεις των στοιχείων του, με $O({\log(n)}^d)$ (για κάποια σταθέρα $d \geq 1$) διαφορετικά στοιχεία. Επομένως ο πίνακας που αποτελείται απο τα διαφορετικά στοιχεία του A, έστω $B[1...k]$, θα έχει πλήθος στοιχείων $k \in O({\log(n)}^d)$. Αν εκμεταλευτούμε την ιδιότητα του πίνακα Α μπορούμε να κατασκευάσουμε συγκριτικό αλγόριθμο ταξινόμησης που θα έχει πολυπλοκότητα $Ο(n\log \log n)$. Θεωρούμε χωρίς βλάβη της γενικότητας ότι ο Α αποτελείται μόνο απο θετικά στοιχεία.
Περιγραφικά, θα χρειαστούμε τις εξής διαδικασίες που θα απαρτίζουν τον αλγόριθμό μας:
\begin{itemize}
%  \item \texttt{max\_array()}: Συνάρτηση που δέχεται ως είσοδο έναν πίνακα και επιστρέφει το μέγιστο (ακέραιο) στοιχείο του .
%  \item \texttt{diff\_num()}: Συνάρτηση που δέχεται ως είσοδο έναν πίνακα και επιστρέφει τoν αριθμό των διαφορετικών στοιχείων του.
 \item \texttt{freq\_array()}: Συνάρτηση που δέχεται ως είσοδο έναν πίνακα (στην δικιά μας περίπτωση τον Α) και μας επιστρέφει έναν πίνακα μεγέθους
\texttt{max\_array(A)} (μέγιστου στοιχείου του πίνακα) που για κάθε θέση του, έστω $i$, δείχνει την αντίστοιχη σύχνοτητα εμφάνισης του $i$ στον Α. Παράλληλα δημιουργεί εναν πίνακα Β που περιέχει μόνο τα διαφορετικά στοιχεία του Α και επιστρεφεί το diff\_num που είναι το πλήθος των διαφορετικών στοιχείων. 
 \item \texttt{qsort\_array()}: Συνάρτηση που ταξινομεί έναν πίνακα με την quick sort.
 \item \texttt{reconstruct\_array()}: Συνάρτηση που κατασκευάζει τον ζητούμενο ταξινομημένο πίνακα.
\end{itemize}

Ακολουθούν σε ψευδογλώσσα οι παραπάνω συναρτήσεις:
% \begin{center}
% \line(1,0){250} 
% \begin{algorithmic}[1]
% \Procedure{$max\_array$}{$A$}
%   \State $max=1$
%   \For {i in $[2...n]$}
%     \If{$A[i]>A[max]$} 
%       \State $max \gets i$ 
%     \EndIf
%   \EndFor
%   \State \textbf{return} max 
% \EndProcedure
% \end{algorithmic}
% \line(1,0){250}
% \end{center}
% % 
% \begin{center}
% \line(1,0){250} 
% \begin{algorithmic}[1]
% \Procedure{$diff\_num$}{$A$}
%   \State $diff=1$
%   \For {i in $[2...n]$}
%     \If{$A[i] \neq A[diff]$} 
%       \State $diff \gets diff+1$ 
%     \EndIf
%   \EndFor
%   \State \textbf{return} diff 
% \EndProcedure
% \end{algorithmic}
% \line(1,0){250} 
% \end{center}

\begin{center}
\line(1,0){250} 
\begin{algorithmic}[1]
\Procedure{$freq\_array$}{$A$}
  \State $j=1$
  \State $initialize(B)$	\Comment{Αρχικοποίηση του πίνακα Β με μηδενικά}
  %\State $diff=diff\_num(A)$
  \For {$i$ in $[1...n]$}
    \If{$B[A[i]] = 0$} 
      \State $Unique[j]=A[i]$	\Comment{Unique: πίνακας διαφορετικών στοιχείων}
      \State $j \gets j+1$
    \EndIf
    \State $B[A[i]] \gets B[A[i]]+1$
  \EndFor
  \State $diff\_num \gets j-1$
  \State \textbf{return} $Unique,B,diff\_num$ 
\EndProcedure
\end{algorithmic}
\line(1,0){250} 
\end{center}
\begin{center}
\line(1,0){250} 
\begin{algorithmic}[1]
\Procedure{$reconstruct\_array$}{$B,Unique,diff\_num$}
  \State $init \gets 1$
  \State $k \gets diff\_num$
  \For {i in $[1...k]$}
    \For {j in $[1...B[Unique[i]]]$}
      \State $A[init] \gets Unique[i]$
      \State $init \gets init+1$
    \EndFor
  \EndFor
  \State \textbf{return} A 
\EndProcedure
\end{algorithmic}
\line(1,0){250} 
\end{center}
Η πολυπλοκότητα του αλγόριθμου μας θα ειναι $O({\log n}^d \log {\log n}^d)$ που όμως είναι ίση με $O(n\log \log n)$ αφού $(\log n)^d \leq n$ (ακόμα και στην χειρότερη περίπτωση το πλήθος των διαφορετικών στοιχείων είναι μικρότερο απο το πλήθος όλων των στοιχείων). Αυτό συμβαίνει αφού αν καλέσουμε κατάλληλα τις παραπάνω συναρτήσεις για την ταξινόμηση του Α, όλες είναι γραμμικής πολυπλοκότητας, εκτός απο την quick sort όπου θέλει $n \log n$ χρόνο. Ομως το μέγεθος του πίνακα που ταξινομεί 
είναι πολυλογαριθμικά μικρότερο απο αυτό του αρχικού πίνακα. Έτσι στην περίπτωση ταξινομήσης σαν και αυτή της άσκησης δεν ισχύει το κάτω φράγμα $\Omega (n \log n)$ γιατί εκμεταλλευόμαστε την ιδιότητα των στοιχείων μειώνοντας την χρονική πολυπλοκότητα αλλά αυξάνοντας πιθανά την χωρική (ο πίνακας Β είναι μεγέθους \texttt{max\_array(A)}, δηλαδή μέγεθος ίσο με το μέγιστο στοιχείο).

\section*{Άσκηση 3: Δυαδική Αναζήτηση}
\subsection*{(α)}

Ο αλγόριθμος για την επίλυση του προβλήματος θα αποτελέιται απο τα εξής βήματα:
\begin{itemize}
 \item Εύρεση της τιμής του n (μέγεθος του πίνακα), σε λογαριθμικό χρόνο.
 \item Εκτέλεση δυαδικής αναζήτησης με δεδομένο το μέγεθος του πίνακα, πάλι σε λογαριθμικό χρόνο.
\end{itemize} 

Έτσι συνολικά η πολυπλοκότητα του αλγορίθμου μας θα είναι $\log n + \log n$ δηλαδή $O(\log n)$. Για το 1ο βήμα:
\begin{itemize}
 \item Ξεκινάμε με δείκτη $i=1$ και τον αυξάνουμε με βήμα $2,2^2,2^3,2^4,...$ μέχρις ότου μας επιστραφεί το μήνυμα σφάλματος $\infty$.
 \item Έστω $2^k$ η θέση του πίνακα όπου κατά την προσπέλαση της εμφανίστηκε το μήνυμα σφάλματος.
 \item Εκτελούμε δυαδική αναζήτηση μεταξύ των θέσεων $2^{k-1}$ και $2^{k}$ μέχρι να βρούμε το ζητούμενο n, γνωρίζοντας ότι θα είναι το τελυταία στοιχείο που δεν θα εμφανιστεί το μήνυμα λάθους.
\end{itemize}

Στη συνέχεια, για το 2ο βήμα, εκτελούμε δυαδική αναζήτηση για το στοιχείο $x$ στον πίνακα $A[1...n]$, αφού γνωρίζουμε πλέον και το μέγεθος του πίνακα Α.

\subsection*{(β)}
Για την επίλυση του προβλήματος σε αυτό το υποερώτημα θα χρειαστεί να εφαρμόσουμε την ιδέα της δυαδικής αναζήτησης στην ένωση 2 πινάκων. 
Αφού οι 2 πίνακες Α,Β είναι ταξινομημένοι και τα στοιχεία τους διαφορετικά, δεν ειναι δυνατό το ζητούμενο στοιχείο να βρίσκεται σε θέση μεγαλύτερη
της $k$. Άρα η αναζήτηση περιορίζεται στα στοιχεία $A[1...k]$, $B[1...k]$. 

\begin{center}
\line(1,0){250} 
\begin{algorithmic}[1]
\Procedure{$k\_smallest$}{$A[n],B[n]$}
  \State $i \gets k$ div $2$
  \State $j \gets k-i$
  \State $step \gets k$ div $4$
  \While {$step >0$}
    \If {$A[i]>B[j]$} 
      \State $i \gets i-step$
      \State $j \gets j+step$
    \Else
      \State $i \gets i+step$
      \State $j \gets j-step$
    \EndIf
    \State $step \gets step$ div $2$
  \EndWhile
  \If {$A[i]>B[j]$}
    \State $x \gets A[i]$
  \Else
    \State $x \gets B[j]$
  \EndIf
  \State \textbf{return} x 
\EndProcedure
\end{algorithmic}
\line(1,0){250} 
\end{center}


\section*{Άσκηση 4: Συλλογή comics}
Η λύση του προβλήματος της \textsc{Συλλογής Comics} στηρίζεται εν μέρη στην ιδέα της δυαδικής αναζήτησης. Συγκεκριμένα, η ιδέα που θα βασιστούμε για την κατασκευή του αλγορίθμου είναι ότι μετά απο κάθε ανάγνωση των ψηφίων ενός comic θα ελλατώνουμε στο μισό τα ψηφία που θα πρέπει να εξεταστούν (δηλ. συμφωνα με την εκφώνηση, τις ερωτήσεις της μορφής \textit{``Ποιό είναι το i-οστό bit στην αρίθμηση του τέυχους j''}) στην επόμενη επανάληψη. Έτσι σε κάθε βήμα χρειάζεται να διαβάζουμε n ψηφία τα οποία στην επόμενη αναζήτηση μειώνονται στο μισό άρα:

\begin{itemize}
 \item $T(n)=n+T(n/2)\Longrightarrow T(n)=2n-2+c1$
 \item \textsc{Πολυπλοκότητα}: $n+\frac{n}{2}+\frac{n}{4}+\frac{n}{8}+...=\sum_{k=0}^{\log n}\frac{n}{2k} \Longrightarrow O(n)$
\end{itemize}

Θεωρούμε ότι ο δείκτης $i$ είναι αρχικά 0 και το σύνολο των τευχών που εξετάζουμε ειναι το $ComicsSet$ με αρχικά όλα τα τευχη. Ακόμα, έστω $ComicsNumber$ κάθε φορά το σύνολο των στοιχείων του $ComicsSet$. Τα βήματα του αλγορίθμου μας θα είναι τα εξής παρακάτω:
\begin{enumerate}
 \item Διάβαζουμε το i-οστό (απο το τέλος) ψηφίο σε κάθε τέυχος του $ComicsSet$ και ανάλογα με το αν είναι 1 η 0 χωρίζουμε τα τεύχη σε 2 σύνολα.
 \item Αν υπάρχουν περισσότερα 0 απο 1 τότε το τεύχος που λείπει βρίσκεται στα $\frac{1}{2} \cdot ComicsNumber$ μεγαλύτερα στοιχεία του τρέχοντος $ComicsSet$. Το τρέχον $ComicsSet$ γίνεται το σύνολο με τα τέυχη με 1 στο i-οστο ψηφίο. 
 \item Αν υπάρχουν περισσότερα 1 απο 0 τότε το τέυχος που λείπει βρίσκεται στα $\frac{1}{2} \cdot ComicsNumber$ μικρότερα στοιχεία του τρέχοντος $ComicsSet$. Το τρέχον $ComicsSet$ γίνεται το σύνολο με τα τέυχη με 0 στο i-οστο ψηφίο.
 \item Πήγαινουμε ξανά στο βήμα 1 για $i = i+1$ μέχρι το $ComicsNumber$ να γίνει 1.
 \item Τέλος το στοιχείο που ψάχνουμε είναι το στοιχείο με αριθμό τεύχους ιδιο με αυτό του τελευταίου στοιχείου του $ComicsSet$, αν αλλάξουμε το Less Significan Bit στο συμπληρωματικό του.
\end{enumerate}


\section*{Άσκηση 5: Πολυκατοικίες χωρίς θέα} 
Για την επίλυση του προβλήματος \textsc{<<Πολυκατοικίες χωρίς θέα>>} θα χρησιμοποιήσουμε μια παραλλαγμένη μορφή του αλγόριθμου που βρίσκει τις κοντινότερες μικρότερες τιμές \textsc{<<All nearest smaller values>>} σε μια ακολουθία αριθμών (πολυπλοκότητα $O(n)$). Στην προκειμένη περίπτωση χρειάζεται να βρούμε όλες τις κοντινότερες μεγαλύτερες τιμές κάθε στοιχείου του πίνακα Α. Ένας αποδοτικός τρόπος για να υλοποιήσουμε το παραπάνω θα είναι χρησιμοποιώντας τη δομή δεδομένων ``στοίβα'' (χρησιμοποιούνται χωρίς να οριστούν οι συναρτήσεις $push()$, $pop()$, $top()$ για την εισαγωγή και εξαγωγή στοιχείων απο την στοιβα και για το κορυφαίο στοιχείο της). Ακολουθεί υλοποίηση του παραπάνω αλγόριθμου σε ψευδογλώσσα:
\begin{itemize}
  \item \textsc{Πολυπλοκότητα Αλγορίθμου}: $O(n)$ 
\end{itemize}
\begin{center}
\line(1,0){250} 
\begin{algorithmic}[1]
\Procedure{$NearestLargerValues$}{$A[n]$}
  \State {$initialize(S)$} \Comment {Αρχικοποίηση άδειας στοίβας S}
  \State {$i \gets 1$}
  \For {$x$ in $A[1...n]$}
    \While {$S$ is nonempty and $top(S) \leq x$}
      \State {$pop(S)$} 
    \EndWhile
    \If {$empty(S)$}
      \State {$x$ has no preceeding larger value}
      \State {$B[i] \gets 0$}
    \Else
      \State {$top(S)$ is the nearest larger value to $x$} 
      \State $B[i] \gets x$
      \State $i \gets i+1$
    \EndIf
    \State {$push(x)$} 
  \EndFor
  \State \textbf{return} $B[n]$ 
\EndProcedure
\end{algorithmic}
\line(1,0){250} 
\end{center} 

Ο αλγόριθμος εκτελείται σε γραμμικό χρόνο, αν και αυτό δεν είναι εμφανές λόγω των εμφωλευμένων επαναλήψεων. Είναι γραμμικής πολυπλοκότητας όμως, αφού κάθε επανάληψη του εσωτερικού βρόγχου αφαιρεί ένα στοιχείο το οποίο είχε προστεθεί σε μια προηγούμενη επανάληψη του εξωτερικού βρόγχου.

\end{document}
